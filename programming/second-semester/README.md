# Курс "Парадигмы программирования"
## Языки: Java, JavaScript, Clojure, Prolog
## Второй семестр



# Условия задач:

## Домашнее задание 14. Дерево поиска на Prolog

1. Реализуйте ассоциативный массив (map) на основе деревьев поиска. Для решения можно реализовать любое дерево поиска логарифмической высоты.
2. Простой вариант. Разработайте правила:
     - `map_build(ListMap, TreeMap)`, строящее дерево из упорядоченного списка пар ключ-значение `(O(n))`;
     - `map_get(TreeMap, Key, Value)`, проверяющее, что массив содержит заданную пару ключ-значение `(O(log n))`.
3. **Сложный вариант**. Дополнительно разработайте правила:
     - `map_put(TreeMap, Key, Value, Result)`; добавляющее пару ключ-значение в массив, или заменяющее текущее значение для ключа `(O(log n))`;
     - `map_remove(TreeMap, Key, Result)` удаляющее отображение для ключа `(O(log n))`;
     - `map_build(ListMap, TreeMap)`, строящее дерево из неупорядоченного списка пар ключ-значение `(O(n log n))`.

Модификации
 * *Базовая*
    * Код должен находиться в файле `tree-map.pl`.
 * *MinMax*
    * Добавьте правила:
        * `map_minKey(Map, Key)`, возвращающее минимальный ключ в дереве,
        * `map_maxKey(Map, Key)`, возвращающее максимальный ключ в дереве.
 * *Replace*
    * Добавьте правило `map_replace(Map, Key, Value, Result)`,
        заменяющего значения ключа на указанное, если ключ присутствует.
 * *FloorKey*
    * Добавьте правило `map_floorKey(Map, Key, FloorKey)`,
      возвращающее максимальный ключ, меньший либо равный заданному.
 * *CeilingKey*
    * Добавьте правило `map_ceilingKey(Map, Key, CeilingKey)`,
      возвращающее минимальный ключ, больший либо равный заданному.
 * *SubmapSize*
    * Добавьте правило `map_submapSize(Map, FromKey, ToKey, Size)`,
      возвращающее число ключей в диапазоне `[FromKey, ToKey)`.


## [Домашнее задание 13. Простые числа на Prolog](https://github.com/xe11us/university/tree/master/programming/second-semester/prolog-prime)

1. Разработайте правила:  
      - `prime(N)`, проверяющее, что `N` – простое число.  
      - `composite(N)`, проверяющее, что `N` – составное число.  
      - `prime_divisors(N, Divisors)`, проверяющее, что список `Divisors` содержит все простые делители числа `N`, упорядоченные по возрастанию. Если `N` делится на простое число `P` несколько раз, то `Divisors` должен содержать соответствующее число копий `P`.  
2. Варианты  
      - Простой: `N ≤ 1000`.  
      - **Сложный**: `N ≤ 100000`.  
3. Вы можете рассчитывать, на то, что до первого запроса будет выполнено правило `init(MAX_N)`.

Модификации
 * *Базовая*
    * Код должен находиться в файле `primes.pl`.
 * *Unique*
    * Добавьте правило `unique_prime_divisors(N, Divisors)`,
      возвращающее простые делители без повторов
 * *Palindrome*
    * Добавьте правило `prime_palindrome(N, K)`,
      определяющее, является ли `N` простым палиндромом в `K`-ичной системе счисления
 * *Nth*
    * Добавьте правило `nth(N, P)`, подсчитывающее `N`-ое простое число
 * *Lcm*
    * Добавьте правило `lcm(A, B, LCM)`,
      подсчитывающее НОК(`A`, `B`) через разложение на простые множители


## Домашнее задание 12. Комбинаторные парсеры

1. Простой вариант. Реализуйте функцию `(parseObjectSuffix "expression")`, разбирающую выражения, записанные в суффиксной форме, и функцию `toStringSuffix`, возвращающую строковое представление выражения в этой форме. Например,  
`(toStringSuffix (parseObjectSuffix "( ( 2 x * ) 3 - )"))`  
должно возвращать `((2 x *) 3 -)`.  
2. **Сложный вариант**. Реализуйте функцию `(parseObjectInfix "expression")`, разбирающую выражения, записанные в инфиксной форме, и функцию `toStringInfix`, возвращающую строковое представление выражения в этой форме. Например,  
`(toStringInfix (parseObjectInfix "2 * x - 3"))`  
должно возвращать `((2 * x) - 3)`.  
3. Функции разбора должны базироваться на библиотеке комбинаторов, разработанной на лекции.

Модификации
 * *Базовая*
    * Код должен находиться в файле `expression.clj`.
 * *Variables*. Дополнительно реализовать поддержку:
    * Переменных, состоящих из произвольного количества букв `XYZ` в любом регистре
        * Настоящее имя переменной определяется первой буквой ее имени
 * *PowLog*. Дополнительно реализовать поддержку:
    * Бинарных правоассоциативных операций максимального приоритета:
        * `Pow` (`**`) – возведения в степень:
            `4 ** 3 ** 2` равно `4 ** (3 ** 2)` равно 262144
        * `Log` (`//`) – взятия логарифма:
            `8 // 9 // 3` равно `8 // (9 // 3)` равно 3
 * *Bitwise*. Дополнительно реализовать поддержку:
    * Побитовых операций
        * `And` (`&`) – и: `5 & 6` равно 4
        * `Or` (`|`) - или: `5 & 6` равно 7
        * `Xor` (`^`) - исключающее или: `5 ^ 6` примерно равно 1.66881E-308
        * для реализации операций используйте
            [doubleToLongBits](https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/lang/Double.html#doubleToLongBits(double))
            и [longBitsToDouble](https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/lang/Double.html#longBitsToDouble(long))
        * операции по увеличению приоритета: `^`, `|`, `&`, `+` и `-`, `*` и `/`
 * *ImplIff*. Сделать модификацию *Bitwise* и дополнительно реализовать поддержку:
    * Побитовых операций
        * `Impl` (`=>`) – импликация (правоассоциативна): `4 => 1` примерно равно -2
        * `Iff` (`<=>`) - тогда и только тогда: `2 <=> 6` примерно равно -1.34827E308
        * операции по увеличению приоритета: `<=>`, `=>`, `^`, `|`, `&`, `+` и `-`, `*` и `/`


## [Домашнее задание 11. Объектные выражения на Clojure](https://github.com/xe11us/university/tree/master/programming/second-semester/clojure-expression)

1. Разработайте конструкторы `Constant`, `Variable`, `Add`, `Subtract`, `Multiply` и `Divide` для представления выражений с одной переменной.  
- Пример описания выражения `2x-3`:  
```
(def expr
  (Subtract
    (Multiply
      (Constant 2)
      (Variable "x"))
    (Const 3)))
```             
- Функция `(evaluate expression vars)` должна производить вычисление выражения `expression` для значений переменных, заданных отображением `vars`. Например, `(evaluate expr {"x" 2})` должно быть равно `1`.  
- Функция `(toString expression)` должна выдавать запись выражения в стандартной для Clojure форме.  
- Функция `(parseObject "expression")` должна разбирать выражения, записанные в стандартной для Clojure форме. Например,  
`(parseObject "(- (* 2 x) 3)")`  
должно быть эквивалентно `expr`.  
- Функция `(diff expression "variable")` должена возвращать выражение, представляющее производную исходного выражения по заданой пермененной. Например, `(diff expression "x")` должен возвращать выражение, эквивалентное `(Constant 2)`, при этом выражения `(Subtract (Const 2) (Const 0))` и  
```  
(Subtract
  (Add
    (Multiply (Const 0) (Variable "x"))
    (Multiply (Const 2) (Const 1)))
  (Const 0))
```                 
так же будут считаться правильным ответом.  
2. **Сложный вариант**. Констуркторы `Add`, `Subtract`, `Multiply` и `Divide` должны принимать произвольное число аргументов. Разборщик так же должен допускать произвольное число аргументов для \+, \-, \*, \/.  
3. При выполнение задания можно использовать любой способ преставления объектов. 

Модификации
 * *Базовая*
    * Код должен находиться в файле `expression.clj`.
 * *SquareSqrt*. Дополнительно реализовать поддержку:
    * унарных операций:
        * `Square` (`square`) – возведение в квадрат, `(square 3)` равно 9;
        * `Sqrt` (`sqrt`) – извлечение квадратного корня из абсолютной величины аргумента, `(sqrt -9)` равно 3.
 * *PwLg*. Дополнительно реализовать поддержку:
    * бинарных операций:
        * `Pw` (`pw`) – возведение в степень, `(pow 2 3)` равно 8;
        * `Lg` (`lg`) – логарифм абсолютной величины по основанию абсолютной величины, `(lg -8 -2)` равно 3.
 * *ExpLn*. Дополнительно реализовать поддержку:
    * унарных операций:
        * `Exp` (`exp`) – экспонента, `(exp 8)` примерно равно 2981;
        * `Ln`  (`Ln`)  – натуральный логарифм абсолютной величины, `(lg 2981)` примерно равно 8.
 * *SumAvg*. Дополнительно реализовать поддержку:
    * операций произвольного числа аргументов:
        * `Sum` (`sum`) – сумма, `(sum 1 2 3)` равно 6;
        * `Avg` (`avg`) – арифметическое среднее, `(avg 1 2 3)` равно 2;
 * *SumexpSoftmax*. Дополнительно реализовать поддержку:
    * операций произвольного числа аргументов:
        * `Sumexp` (`sumexp`) – сумма экспонент, `(sumexp 8 8 9)` примерно равно 14065;
        * `Softmax` (`Softmax`) – [softmax](https://ru.wikipedia.org/wiki/Softmax) первого аргумента, `(softmax 1 2 3)` примерно равно 0.09;


## [Домашнее задание 10. Функциональные выражения на Clojure](https://github.com/xe11us/university/tree/master/programming/second-semester/clojure-expression)

1. Разработайте функции `constant`, `variable`, `add`, `subtract`, `multiply` и `divide` для представления арифметических выражений.
- Пример описания выражения `2x-3`:
```
(def expr
(subtract
(multiply
(constant 2)
(variable "x"))
(constant 3)))
```
- Выражение должно быть функцией, возвращающей значение выражение при подстановке элементов, заданных отображением. Например, `(expr {"x" 2})` должно быть равно `1`.
2. Разработайте разборщик выражений, читающий выражения в стандартной для Clojure форме.
Например, `(parseFunction "(- (* 2 x) 3)")` должно быть эквивалентно `expr`.
3. **Сложный вариант**. Функции `add`, `subtract`, `multiply` и `divide` должны принимать произвольное число аргументов. Разборщик так же должен допускать произвольное число аргументов для \+, \-, \*.
4. При выполнение задания следует обратить внимание на выделение общего кода для операций.

Модификации
 * *Базовая*
    * Код должен находиться в файле expression.clj.
 * *PwLg*. Дополнительно реализовать поддержку:
    * бинарных операций:
        * `pw` – возведение в степень, `(pow 2 3)` равно 8;
        * `lg` – логарифм абсолютной величины по основанию абсолютной величины, `(lg -8 -2)` равно 3.
 * *ExpLn*. Дополнительно реализовать поддержку:
    * унарных операций:
        * `exp` – экспонента, `(exp 8)` примерно равно 2981;
        * `ln`  – натуральный логарифм абсолютной величины, `(ln -2981)` примерно равно 8.
 * *MinMax*. Дополнительно реализовать поддержку:
    * операций произвольного числа аргументов:
        * `min` – минимум, `(min 1 2 6)` равно 1;
        * `max` – максимум, `(min 1 2 6)` равно 6;
 * *MedAvg*. Дополнительно реализовать поддержку:
    * операций произвольного числа аргументов:
        * `med` – медиана, `(med 1 2 6)` равно 2;
        * `avg` – среднее, `(avg 1 2 6)` равно 3;
 * *SumexpSoftmax*. Дополнительно реализовать поддержку:
    * операций произвольного числа аргументов:
        * `sumexp` – сумма экспонент, `(sumexp 8 8 9)` примерно равно 14065;
        * `softmax` – [softmax](https://ru.wikipedia.org/wiki/Softmax) первого аргумента, `(softmax 1 2 3)` примерно равно 0.09;


## [Домашнее задание 9. Линейная алгебра на Clojure](https://github.com/xe11us/university/tree/master/programming/second-semester/clojure-linear)

1. Разработайте функции для работы с объектами линейной алгебры, которые представляются следующим образом:
- скаляры – числа
- векторы – векторы чисел;
- матрицы – векторы векторов чисел.
2. Функции над векторами:
- `v+`/`v-`/`v*` – покоординатное сложение/вычитание/умножение;
- `scalar`/`vect` – скалярное/векторное произведение;
- `v*s` – умножение на скаляр.
3. Функции над матрицами:
- `m+`/`m-`/`m*` – поэлементное сложение/вычитание/умножение;
- `m*s` – умножение на скаляр;
- `m*v` – умножение на вектор;
- `m*m` – матричное умножение;
- `transpose` – траспонирование;
4. **Сложный вариант**.
- Ко всем функциям должны быть указаны контракты. Например, нельзя складывать вектора разной длины.
- Все функции должны поддерживать произвольное число аргументов. Например `(v+ [1 2] [3 4] [5 6])` должно быть равно `[9 12]`.
5. При выполнение задания следует обратить внимание на:
- Применение функций высшего порядка.
- Выделение общего кода для операций. 

Модификации
 * *Базовая*
    * Код должен находиться в файле `linear.clj`.
 * *Shapeless*
    * Добавьте операции поэлементного сложения (`s+`),
        вычитания (`s-`) и умножения (`s*`) чисел и
        векторов любой (в том числе, переменной) формы.
        Например, `(s+ [[1 2] 3] [[4 5] 6])` должно быть равно `[[5 7] 9]`.
 * *Cuboid*
    * Назовем _кубоидом_ трехмерную прямоугольную таблицу чисел.
    * Добавьте операции поэлементного сложения (`c+`),
        вычитания (`c-`), умножения (`c*`) и деления (`cd`) кубоидов.
        Например, `(с+ [[[1] [2]] [[3] [4]]] [[[5] [6]] [[7] [8]]])` должно быть равно `[[[6] [8]] [[10] [12]]]`.
 * *Tensor*
    * Назовем _тензором_ многомерную прямоугольную таблицу чисел.
    * Добавьте операции поэлементного сложения (`t+`),
        вычитания (`t-`) и умножения (`t*`) тензоров.
        Например, `(t+ [[1 2] [3 4]] [[5 6] [7 8]])` должно быть равно `[[6 8] [10 12]]`.
 * *Broadcast*
    * Назовем _тензором_ многомерную прямоугольную таблицу чисел.
    * _Форма_ тензора – последовательность чисел
        (_s_<sub>1..n</sub>)=(_s_<sub>1</sub>, _s_<sub>2</sub>, …, _s<sub>n</sub>_), где
        _n_ – размерность тензора, а _s<sub>i</sub>_ – число элементов
        по _i_-ой оси.
      Например, форма тензора `[ [ [2 3 4] [5 6 7] ] ]`  равна (1, 2, 3),
      а форма `1` равна ().
    * Тензор формы (_s_<sub>1.._n_</sub>) может быть _распространен_ (broadcast)
      до тензора формы (_u_<sub>1.._m_</sub>), если (_s_<sub>i.._n_</sub>) является
      суффиксом (_u<sub>1..m</sub>_). Для этого, исходный тензор копируется
      по недостающим осям.
      Например, распространив тензор `[ [2] [3] ]` формы (2, 1) до
      формы (3, 2, 1) получим `[ [ [2] [3] ] [ [2] [3] ] [ [2] [3] ] ]`,
      а распространив `1` до формы (2, 3) получим `[ [1 1 1] [1 1 1] ]`.
    * Тензоры называются совместимыми, если один из них может быть распространен
      до формы другого.
      Например, тензоры формы (3, 2, 1) и (2, 1) совместимы, а
      (3, 2, 1) и (1, 2) – нет. Числа совместимы с тензорами любой формы.
    * Добавьте операции поэлементного сложения (`b+`),
      вычитания (`b-`), умножения (`b*`) и деления умножения (`bd`)
      совместимых тензоров.
      Если формы тензоров не совпадают, то тензоры меньшей размерности
      должны быть предварительно распространены до тензоров большей размерности.
      Например, `(b+ 1 [ [10 20 30] [40 50 60] ] [100 200 300] )` должно
      быть равно `[ [111 221 331] [141 251 361] ]`.


## [Домашнее задание 8. Обработка ошибок на JavaScript](https://github.com/xe11us/university/tree/master/programming/second-semester/javascript-functional-object-expression)

1. Добавьте в предыдущее домашнее задание функцию `parsePrefix(string)`, разбирающую выражения, задаваемые записью вида `(- (* 2 x) 3)`. Если разбираемое выражение некорректно, метод `parsePrefix` должен бросать человеко-читаемое сообщение об ошибке.
2. Добавьте в предыдущее домашнее задание метод `prefix()`, выдающий выражение в формате, ожидаемом функцией `parsePrefix`.
3. При выполнение задания следует обратить внимание на:
- Применение инкапсуляции.
- Выделение общего кода для бинарных операций.
- Обработку ошибок.
- Минимизацию необходимой памяти. 

Модификации
 * *Базовая*
    * Код должен находиться в файле `objectExpression.js`.
 * *PrefixAtanExp*. Дополнительно реализовать поддержку:
    * унарных операций:
        * `ArcTan` (`atan`) – арктангенс, `(atan 2)` примерно равно 1.1;
        * `Exp` (`Exp`) – экспонента, `(exp 3)` примерно равно 20;
 * *PrefixSinhCosh*. Дополнительно реализовать поддержку:
    * унарных операций:
        * `Sinh` (`sinh`) – гиперболический синус, `(sinh 3)` немного больше 10;
        * `Cosh` (`cosh`) – гиперболический косинус, `(cosh 3)` немного меньше 10;
 * *PrefixSumAvg*. Дополнительно реализовать поддержку:
    * операций произвольного числа аргументов:
        * `Sum` (`sum`) – сумма, `(sum 1 2 3)` равно 6;
        * `Avg` (`avg`) – арифметическое среднее, `(avg 1 2 3)` равно 2;
 * *PostfixSumAvg*. Дополнительно реализовать поддержку:
    * выражений в постфиксной записи: `(2 3 +)` равно 5
    * унарных операций:
        * `Sum` (`sum`) – сумма, `(1 2 3 sum)` равно 6;
        * `Avg` (`avg`) – арифметическое среднее, `(1 2 3 avg)` равно 2;
 * *PostfixSumexpSoftmax*. Дополнительно реализовать поддержку:
    * выражений в постфиксной записи: `(2 3 +)` равно 5
    * унарных операций:
        * `Sumexp` (`sumexp`) – сумма экспонент, `(8 8 9 sumexp)` примерно равно 14065;
        * `Softmax` (`softmax`) – [softmax](https://ru.wikipedia.org/wiki/Softmax) первого аргумента, `(1 2 3 softmax)` примерно 0.09;
 * *PostfixMeanVar*. Дополнительно реализовать поддержку:
    * выражений в постфиксной записи: `(2 3 +)` равно 5
    * операций произвольного числа аргументов:
        * `Mean` (`mean`) – математическое ожидание аргументов, `(1 2 6 mean)` равно 3;
        * `Var` (`var`) – дисперсию аргументов, `(2 5 11 var)` равно 14;


## [Домашнее задание 7. Объектные выражения на JavaScript](https://github.com/xe11us/university/tree/master/programming/second-semester/javascript-functional-object-expression)

1. Разработайте классы `Const`, `Variable`, `Add`, `Subtract`, `Multiply`, `Divide`, `Negate` для представления выражений с одной переменной.
- Пример описания выражения `2x-3`:
```
let expr = new Subtract(
new Multiply(
new Const(2),
new Variable("x")
),
new Const(3)
);
```
- Метод `evaluate(x)` должен производить вычисления вида: При вычислении такого выражения вместо каждой переменной подставляется значение `x`, переданное в качестве параметра функции `evaluate` (на данном этапе имена переменных игнорируются). Таким образом, результатом вычисления приведенного примера должно стать число `7`.
- Метод `toString()` должен выдавать запись выражения в обратной польской записи. Например, `expr.toString()` должен выдавать `2 x * 3 -`.
2. **Сложный вариант**.
 Метод `diff("x")` должен возвращать выражение, представляющее производную исходного выражения по переменной `x`. Например, `expr.diff("x")` должен возвращать выражение, эквивалентное 
`new Const(2)` (выражения `new Subtract(new Const(2), new Const(0))` и
```
new Subtract(
new Add(
new Multiply(new Const(0), new Variable("x")),
new Multiply(new Const(2), new Const(1))
)
new Const(0)
)
```
так же будут считаться правильным ответом).
                                          Функция `parse` должна выдавать разобранное объектное выражение.

3. **Бонусный вариант** (deleted to avoid copy-paste). Требуется написать метод `simplify()`, производящий вычисления константных выражений. Например,
`parse("x x 2 - * 1 *").diff("x").simplify().toString()` должно возвращать `x x 2 - +`.
4. При выполнение задания следует обратить внимание на:
- Применение инкапсуляции.
- Выделение общего кода для операций.

Модификации
 * *Базовая*
    * Код должен находиться в файле `objectExpression.js`.
 * *PowLog*. Дополнительно реализовать поддержку:
    * бинарных операций:
        * `Power` (`pow`) – возведение в степень, `2 3 pow` равно 8;
        * `Log` (`log`) – логарифм абсолютного значения аргумента
            по абсолютному значению основания `-2 -8 log` равно 3;
 * *SinhCosh*. Дополнительно реализовать поддержку:
    * унарных функций:
        * `Sinh` (`sinh`) – гиперболический синус, `3 sinh` немного больше 10;
        * `Cosh` (`cosh`) – гиперболический косинус, `3 cosh` немного меньше 10;
 * *MinMax*. Дополнительно реализовать поддержку:
    * функций:
        * `Min3` (`min3`) – минимум из трех аргументов, `1 2 3 min` равно 1;
        * `Max5` (`max5`) – максимум из пяти аргументов, `1 2 3 4 5 max` равно 5;
 * *Gauss*. Дополнительно реализовать поддержку:
    * функций:
        * `Gauss` (`gauss`) – [функция Гаусса](https://ru.wikipedia.org/wiki/%D0%93%D0%B0%D1%83%D1%81%D1%81%D0%BE%D0%B2%D0%B0_%D1%84%D1%83%D0%BD%D0%BA%D1%86%D0%B8%D1%8F);
          от четырех аргументов: `a`, `b`, `c`, `x`.


## [Домашнее задание 6. Функциональные выражения на JavaScript](https://github.com/xe11us/university/tree/master/programming/second-semester/javascript-functional-object-expression)

1. Разработайте функции `cnst`, `variable`, `add`, `subtract`, `multiply`, `divide`, `negate` для вычисления выражений с одной переменной.
2. Функции должны позволять производить вычисления вида:
```
let expr = subtract(
multiply(
cnst(2),
variable("x")
),
cnst(3)
);
println(expr(5));
```
При вычислении такого выражения вместо каждой переменной подставляется значение, переданное в качестве параметра функции `expr` (на данном этапе имена переменных игнорируются). Таким образом, результатом вычисления приведенного примера должно стать число `7`.
3. Тестовая программа должна вычислять выражение `x2−2x+1`, для `x` от `0` до `10`.
4. **Сложный вариант**. Требуется написать функцию `parse`, осуществляющую разбор выражений, записанных в обратной польской записи. Например, результатом `parse("x x 2 - * x * 1 +")(5)` должно быть число `76`.
5. При выполнение задания следует обратить внимание на:
 * Применение функций высшего порядка.
 * Выделение общего кода для бинарных операций.

Модификации
 * *Базовая*
    * Код должен находиться в файле `functionalExpression.js`.
 * *Mini*
    * Не поддерживаются бинарные операции
    * Код находится в файле functionalMiniExpression.js.
 * *Cube*. Дополнительно реализовать поддержку:
    * переменных: `y`, `z`;
    * унарных функций:
        * `cube` – возведение в куб, `2 cube` равно 8;
        * `cuberoot` – кубический корень, `-8 cuberoot` равно -2;
 * *OneIffAbs*. Дополнительно реализовать поддержку:
    * переменных: `y`, `z`;
    * констант:
        * `one` – 1;
        * `two` – 2;
    * операций:
        * `abs` – абсолютное значение, `-2 abs` равно 2;
        * `iff` – условный выбор:
            если первый аргумент неотрицательный,
            вернуть второй аргумент,
            иначе вернуть первый третий аргумент.
            * `one two 3 iff` равно 2
            * `-1 -2 -3 iff` равно -3
            * `0 one two iff` равно 1;
 * *PieAvgMed*. Дополнительно реализовать поддержку:
    * переменных: `y`, `z`;
    * констант:
        * `pi` – π;
        * `e` – основание натурального логарифма;
    * операций:
        * `avg5` – арифметическое среднее пяти аргументов, `1 2 3 4 5 avg5` равно 7.5;
        * `med3` – медиана трех аргументов, `1 2 -10 med3` равно 1.
 * *PieSinCos*. Дополнительно реализовать поддержку:
    * переменных: `y`, `z`;
    * констант:
        * `pi` – π;
        * `e` – основание натурального логарифма;
    * операций:
        * `sin` – синус, `pi sin` равно 0;
        * `cos` – косинус, `pi cos` равно -1.


## [Домашнее задание 5. Вычисление в различных типах](https://github.com/xe11us/university/tree/master/programming/second-semester/java-expression)

1. Добавьте в программу разбирающую и вычисляющую выражения поддержку различных типов.
- Первым аргументом командной строки программа должна принимать указание на тип, в котором будут производится вычисления:
**Опция**	**Тип**
-i  	    int
-d	      double
-bi	      [BigInteger](http://docs.oracle.com/javase/8/docs/api/java/math/BigInteger.html)
- Вторым аргументом командной строки программа должна принимать выражение для вычисления.
- Реализация не должна содержать [непроверяемых преобразований типов](http://docs.oracle.com/javase/specs/jls/se8/html/jls-5.html#jls-5.1.9).
- Реализация не должна использовать аннотацию [@SuppressWarnings](http://docs.oracle.com/javase/specs/jls/se8/html/jls-9.html#jls-9.6.4.5).
2. При выполнении задания следует обратить внимание на легкость добавления новых типов и операциий. 

Модификации
 * *Базовая*
    * Класс `GenericTabulator` должен реализовывать интерфейс
      Tabulator и
      сроить трехмерную таблицу значений заданного выражения.
        * `mode` – режим вычислений:
           * `i` – вычисления в `int` с проверкой на переполнение;
           * `d` – вычисления в `double` без проверки на переполнение;
           * `bi` – вычисления в `BigInteger`.
        * `expression` – выражение, для которого надо построить таблицу;
        * `x1`, `x2` – минимальное и максимальное значения переменной `x` (включительно)
        * `y1`, `y2`, `z1`, `z2` – аналогично для `y` и `z`.
        * Результат: элемент `result[i][j][k]` должен содержать
          значение выражения для `x = x1 + i`, `y = y1 + j`, `z = z1 + k`.
          Если значение не определено (например, по причине переполнения),
          то соответствующий элемент должен быть равен `null`.
 * *Сmm*
    * Дополнительно реализовать унарные операции:
        * `count` – число установленных битов, `count 5` равно 2.
    * Дополнительно реализовать бинарную операцию (минимальный приоритет):
        * `min` – минимум, `2 min 3` равно 2;
        * `max` – максимум, `2 max 3` равно 3.
 * *Ls*
    * Дополнительно реализовать поддержку режимов:
        * `l` – вычисления в `long` без проверки на переполнение;
        * `s` – вычисления в `short` без проверки на переполнение.
 * *CmmUls*
    * Реализовать операции из модификации *Cmm*.
    * Дополнительно реализовать поддержку режимов:
        * `u` – вычисления в `int` без проверки на переполнение;
        * `l` – вычисления в `long` без проверки на переполнение;
        * `s` – вычисления в `s` без проверки на переполнение.
 * *CmmUfb*
    * Реализовать операции из модификации *Cmm*.
    * Дополнительно реализовать поддержку режимов:
        * `u` – вычисления в `int` без проверки на переполнение;
        * `f` – вычисления в `float` без проверки на переполнение;
        * `b` – вычисления в `byte` без проверки на переполнение.


## [Домашнее задание 4. Очередь на связном списке](https://github.com/xe11us/university/tree/master/programming/second-semester/java-queue)

1. Определите интерфейс очереди `Queue` и опишите его контракт.
2. Реализуйте класс `LinkedQueue` — очередь на связном списке.
3. Выделите общие части классов `LinkedQueue` и `ArrayQueue` в базовый класс `AbstractQueue`. 

Модификации
 * *Базовая*
 * *ToArray*
    * Добавить в интерфейс очереди и реализовать метод
      `toArray`, возвращающий массив,
      содержащий элементы, лежащие в очереди в порядке
      от головы к хвосту
    * Исходная очередь должна оставаться неизменной
    * Дублирования кода быть не должно
 * *Functions*
    * Добавить в интерфейс очереди и реализовать методы
        * `filter(predicate)` – создать очередь, содержащую элементы, удовлетворяющие
            [предикату](https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/util/function/Predicate.html)
        * `map(function)` – создать очередь, содержащую результаты применения
            [функции](https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/util/function/Function.html)
    * Исходная очередь должна остаться неизменной
    * Тип возвращаемой очереди должен соответствовать типу исходной очереди
    * Взаимный порядок элементов должен сохраняться
    * Дублирования кода быть не должно
 * *IfWhile*
    * Добавить в интерфейс очереди и реализовать методы
        * `removeIf(predicate)` – удалить элементы, удовлетворяющие
            [предикату](https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/util/function/Predicate.html)
        * `retainIf(predicate)` – удалить элементы, не удовлетворяющие
            [предикату](https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/util/function/Predicate.html)
        * `takeWhile(predicate)` – сохранить подряд идущие элементы, удовлетворяющие
            [предикату](https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/util/function/Predicate.html)
        * `dropWhile(predicate)` – удалить подряд идущие элементы, не удовлетворяющие
            [предикату](https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/util/function/Predicate.html)
    * Взаимный порядок элементов должен сохраняться
    * Дублирования кода быть не должно


## [Домашнее задание 3. Очередь на массиве](https://github.com/xe11us/university/tree/master/programming/second-semester/java-queue)

1. Найдите инвариант структуры данных «[очередь](http://ru.wikipedia.org/wiki/Очередь_(программирование))». Определите функции, которые необходимы для реализации очереди. Найдите их пред- и постусловия, при условии что очередь не содержит `null`.
2. Реализуйте классы, представляющие циклическую очередь с применением массива.
- Класс `ArrayQueueModule` должен реализовывать один экземпляр очереди с использованием переменных класса.
- Класс `ArrayQueueADT` должен реализовывать очередь в виде абстрактного типа данных (с явной передачей ссылки на экземпляр очереди).
- Класс `ArrayQueue` должен реализовывать очередь в виде класса (с неявной передачей ссылки на экземпляр очереди).
- Должны быть реализованы следующие функции (процедуры) / методы:
                                                          + `enqueue` – добавить элемент в очередь;
+ `element` – первый элемент в очереди;
+ `dequeue` – удалить и вернуть первый элемент в очереди;
+ `size` – текущий размер очереди;
+ `isEmpty` – является ли очередь пустой;
+ `clear` – удалить все элементы из очереди.
- Инвариант, пред- и постусловия записываются в исходном коде в виде комментариев.
- Обратите внимание на инкапсуляцию данных и кода во всех трех реализациях.
3. Напишите тесты к реализованным классам.  

Модификации
 * *Базовая*
    * Классы должны находиться в пакете `queue`
 * *ToArray* (простая)
    * Реализовать метод `toArray`, возвращающий массив,
      содержащий элементы, лежащие в очереди в порядке
      от головы к хвосту.
    * Исходная очередь должна остаться неизменной
    * Дублирования кода быть не должно
 * *ToStr* (простая)
    * Реализовать метод `toStr`, возвращающий строковое представление
      очереди в виде '`[`' _голова_ '`, `' ... '`, `' _хвост_ '`]`'
 * *Deque* (сложная)
    * Реализовать методы
        * `push` – добавить элемент в начало очереди
        * `peek` – вернуть последний элемент в очереди
        * `remove` – вернуть и удалить последний элемент из очереди
 * *IndexedDeque*
    * Реализовать модификацию *Deque*
    * Реализовать методы
        * `get` – получить элемент по индексу, отсчитываемому с головы
        * `set` – заменить элемент по индексу, отсчитываемому с головы


## Домашнее задание 2. Бинарный поиск

1. Реализуйте итеративный и рекурсивный варианты бинарного поиска в массиве.
2. На вход подается целое число `x` и массив целых чисел `a`, отсортированный по невозрастанию. Требуется найти минимальное значение индекса `i`, при котором `a[i] <= x`.
3. Для функций бинарного поиска и вспомогательных функций должны быть указаны, пред- и постусловия. Для реализаций методов должны быть приведены доказательства соблюдения контрактов в терминах троек Хоара.
4. Интерфейс программы.
- Имя основного класса — `BinarySearch`.
- Первый аргумент командной строки — число `x`.
- Последующие аргументы командной строки — элементы массива `a`.
5. Пример запуска: `java BinarySearch 3 5 4 3 2 1`. Ожидаемый результат: `2`.

Модификации
 * *Базовая*
    * Класс `BinarySearch` должен находиться в пакете `search`
 * *Missing*
    * Если в массиве `a` отсутствует элемент, равный `x`, то требуется
      вывести индекс вставки в формате, определенном в
      [`Arrays.binarySearch`](http://docs.oracle.com/javase/8/docs/api/java/util/Arrays.html#binarySearch-int:A-int-).
    * Класс должен иметь имя `BinarySearchMissing`
 * *Span*
    * Требуется вывести два числа: начало и длину диапазона элементов,
      равных `x`. Если таких элементов нет, то следует вывести
      пустой диапазон, у которого левая граница совпадает с местом
      вставки элемента `x`.
    * Не допускается использование типов `long` и `BigInteger`.
    * Класс должен иметь имя `BinarySearchSpan`
 * *Shift*
    * На вход подается отсортированный массив, циклически сдвинутый на `k`
      элементов. Требуется найти `k`. Все числа в массиве различны.
    * Класс должен иметь имя `BinarySearchShift`


## [Домашнее задание 1. Обработка ошибок](https://github.com/xe11us/university/tree/master/programming/second-semester/java-expression)

 1. Доработайте домашнее задание Expression, так что бы выражение строилось по записи вида
`x * (x - 2)*x + 1`  
 2. В записи выражения могут встречаться: умножение \*, деление /, сложение +, вычитание -, унарный минус -, целочисленные константы (в десятичной системе счисления, которые помещаются в 32-битный знаковый целочисленный тип), круглые скобки, переменные (x) и произвольное число пробельных символов в любом месте (но не внутри констант).  
 3. Приоритет операторов, начиная с наивысшего  
    - унарный минус;  
    - умножение и деление;  
    - сложение и вычитание.  
 4. Разбор выражений рекомендуется производить [методом рекурсивного спуска](https://ru.wikibooks.org/wiki/Реализации_алгоритмов/Метод_рекурсивного_спуска). Алгоритм должен работать за линейное время.  
 5. Добавьте в программу вычисляющую выражения обработку ошибок, в том числе:
    - ошибки разбора выражений;
    - ошибки вычисления выражений.
 6. Для выражения `1000000*x*x*x*x*x/(x-1)` вывод программы должен иметь следующий вид:
```  
x       f
0       0
1       division by zero
2       32000000
3       121500000
4       341333333
5       overflow
6       overflow
7       overflow
8       overflow
9       overflow
10      overflow
Результат division by zero (overflow) означает, что в процессе вычисления произошло деление на ноль (переполнение).
```  
 7. При выполнении задания следует обратить внимание на дизайн и обработку исключений.
 8. Человеко-читаемые сообщения об ошибках должны выводится на консоль.
 9. Программа не должна «вылетать» с исключениями (как стандартными, так и добавленными).

Модификации
 * *Базовая*
    * Класс `ExpressionParser` должен реализовывать интерфейс Parser
    * Классы `CheckedAdd`, `CheckedSubtract`, `CheckedMultiply`,
        `CheckedDivide` и `CheckedNegate` должны реализовывать интерфейс TripleExpression
    * Нельзя использовать типы `long` и `double`
    * Нельзя использовать методы классов `Math` и `StrictMath`
 * *PowLog2*
    * Дополнительно реализуйте унарные операции:
        * `log2` – логарифм по уснованию 2, `log2 10` равно 3;
        * `pow2` – два в степени, `pow2 4` равно 16.
 * *PowLog*
    * Дополнительно реализуйте бинарные операции (максимальный приоритет):
        * `**` – возведение в степень, `2 ** 3` равно 8;
        * `//` – логарифм, `10 // 2` равно 3.